import { Inject, Injectable, Optional } from '@angular/core';
import { BehaviorSubject, combineLatest, EMPTY, forkJoin, from, of, Subject, } from 'rxjs';
import { catchError, map, retry, shareReplay, switchMap, tap, } from 'rxjs/operators';
import { DefaultLoader, TRANSLOCO_LOADER, } from './transloco.loader';
import { TRANSLOCO_TRANSPILER, } from './transloco.transpiler';
import { flatten, isEmpty, isNil, isScopeObject, isString, size, toCamelCase, unflatten, } from './helpers';
import { defaultConfig, TRANSLOCO_CONFIG, } from './transloco.config';
import { TRANSLOCO_MISSING_HANDLER, } from './transloco-missing-handler';
import { TRANSLOCO_INTERCEPTOR, } from './transloco.interceptor';
import { TRANSLOCO_FALLBACK_STRATEGY, } from './transloco-fallback-strategy';
import { mergeConfig } from './merge-config';
import { getEventPayload, getLangFromScope, getScopeFromLang, resolveInlineLoader, } from './shared';
import { getFallbacksLoaders } from './get-fallbacks-loaders';
import { resolveLoader } from './resolve-loader';
import * as i0 from "@angular/core";
let service;
export function translate(key, params = {}, lang) {
    return service.translate(key, params, lang);
}
export function translateObject(key, params = {}, lang) {
    return service.translateObject(key, params, lang);
}
export class TranslocoService {
    constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {
        this.loader = loader;
        this.parser = parser;
        this.missingHandler = missingHandler;
        this.interceptor = interceptor;
        this.userConfig = userConfig;
        this.fallbackStrategy = fallbackStrategy;
        this.subscription = null;
        this.translations = new Map();
        this.cache = new Map();
        this.defaultLang = '';
        this.availableLangs = [];
        this.isResolvedMissingOnce = false;
        this.failedLangs = new Set();
        this.events = new Subject();
        this.events$ = this.events.asObservable();
        if (!this.loader) {
            this.loader = new DefaultLoader(this.translations);
        }
        service = this;
        this.mergedConfig = mergeConfig(defaultConfig, this.userConfig);
        this.setAvailableLangs(this.mergedConfig.availableLangs || []);
        this.setFallbackLangForMissingTranslation(this.mergedConfig);
        this.setDefaultLang(this.mergedConfig.defaultLang);
        this.lang = new BehaviorSubject(this.getDefaultLang());
        // Don't use distinctUntilChanged as we need the ability to update
        // the value when using setTranslation or setTranslationKeys
        this.langChanges$ = this.lang.asObservable();
        /**
         * When we have a failure, we want to define the next language that succeeded as the active
         */
        this.subscription = this.events$.subscribe((e) => {
            if (e.type === 'translationLoadSuccess' && e.wasFailure) {
                this.setActiveLang(e.payload.langName);
            }
        });
    }
    get config() {
        return this.mergedConfig;
    }
    getDefaultLang() {
        return this.defaultLang;
    }
    setDefaultLang(lang) {
        this.defaultLang = lang;
    }
    getActiveLang() {
        return this.lang.getValue();
    }
    setActiveLang(lang) {
        this.lang.next(lang);
        this.parser.onLangChanged?.(lang);
        this.events.next({
            type: 'langChanged',
            payload: getEventPayload(lang),
        });
        return this;
    }
    setAvailableLangs(langs) {
        this.availableLangs = langs;
    }
    /**
     * Gets the available languages.
     *
     * @returns
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    getAvailableLangs() {
        return this.availableLangs;
    }
    load(path, options = {}) {
        const cached = this.cache.get(path);
        if (cached) {
            return cached;
        }
        let loadTranslation;
        const isScope = this._isLangScoped(path);
        let scope;
        if (isScope) {
            scope = getScopeFromLang(path);
        }
        const loadersOptions = {
            path,
            mainLoader: this.loader,
            inlineLoader: options.inlineLoader,
            data: isScope ? { scope: scope } : undefined,
        };
        if (this.useFallbackTranslation(path)) {
            // if the path is scope the fallback should be `scope/fallbackLang`;
            const fallback = isScope
                ? `${scope}/${this.firstFallbackLang}`
                : this.firstFallbackLang;
            const loaders = getFallbacksLoaders({
                ...loadersOptions,
                fallbackPath: fallback,
            });
            loadTranslation = forkJoin(loaders);
        }
        else {
            const loader = resolveLoader(loadersOptions);
            loadTranslation = from(loader);
        }
        const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap((translation) => {
            if (Array.isArray(translation)) {
                translation.forEach((t) => {
                    this.handleSuccess(t.lang, t.translation);
                    // Save the fallback in cache so we'll not create a redundant request
                    if (t.lang !== path) {
                        this.cache.set(t.lang, of({}));
                    }
                });
                return;
            }
            this.handleSuccess(path, translation);
        }), catchError((error) => {
            if (!this.mergedConfig.prodMode) {
                console.error(`Error while trying to load "${path}"`, error);
            }
            return this.handleFailure(path, options);
        }), shareReplay(1));
        this.cache.set(path, load$);
        return load$;
    }
    /**
     * Gets the instant translated value of a key
     *
     * @example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     */
    translate(key, params = {}, lang = this.getActiveLang()) {
        if (!key)
            return key;
        const { scope, resolveLang } = this.resolveLangAndScope(lang);
        if (Array.isArray(key)) {
            return key.map((k) => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));
        }
        key = scope ? `${scope}.${key}` : key;
        const translation = this.getTranslation(resolveLang);
        const value = translation[key];
        if (!value) {
            return this._handleMissingKey(key, value, params);
        }
        return this.parser.transpile(value, params, translation);
    }
    /**
     * Gets the translated value of a key as observable
     *
     * @example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     */
    selectTranslate(key, params, lang, _isObject = false) {
        let inlineLoader;
        const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject
            ? this.translateObject(key, params, lang)
            : this.translate(key, params, lang)));
        if (isNil(lang)) {
            return this.langChanges$.pipe(switchMap((lang) => load(lang)));
        }
        if (isScopeObject(lang)) {
            // it's a scope object.
            const providerScope = lang;
            lang = providerScope.scope;
            inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);
        }
        lang = lang;
        if (this.isLang(lang) || this.isScopeWithLang(lang)) {
            return load(lang);
        }
        // it's a scope
        const scope = lang;
        return this.langChanges$.pipe(switchMap((lang) => load(`${scope}/${lang}`, { inlineLoader })));
    }
    /**
     * Whether the scope with lang
     *
     * @example
     *
     * todos/en => true
     * todos => false
     */
    isScopeWithLang(lang) {
        return this.isLang(getLangFromScope(lang));
    }
    translateObject(key, params = {}, lang = this.getActiveLang()) {
        if (isString(key) || Array.isArray(key)) {
            const { resolveLang, scope } = this.resolveLangAndScope(lang);
            if (Array.isArray(key)) {
                return key.map((k) => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));
            }
            const translation = this.getTranslation(resolveLang);
            key = scope ? `${scope}.${key}` : key;
            const value = unflatten(this.getObjectByKey(translation, key));
            /* If an empty object was returned we want to try and translate the key as a string and not an object */
            return isEmpty(value)
                ? this.translate(key, params, lang)
                : this.parser.transpile(value, params, translation);
        }
        const translations = [];
        for (const [_key, _params] of this.getEntries(key)) {
            translations.push(this.translateObject(_key, _params, lang));
        }
        return translations;
    }
    selectTranslateObject(key, params, lang) {
        if (isString(key) || Array.isArray(key)) {
            return this.selectTranslate(key, params, lang, true);
        }
        const [[firstKey, firstParams], ...rest] = this.getEntries(key);
        /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,
         * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */
        return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map((value) => {
            const translations = [value];
            for (const [_key, _params] of rest) {
                translations.push(this.translateObject(_key, _params, lang));
            }
            return translations;
        }));
    }
    getTranslation(langOrScope) {
        if (langOrScope) {
            if (this.isLang(langOrScope)) {
                return this.translations.get(langOrScope) || {};
            }
            else {
                // This is a scope, build the scope value from the translation object
                const { scope, resolveLang } = this.resolveLangAndScope(langOrScope);
                const translation = this.translations.get(resolveLang) || {};
                return this.getObjectByKey(translation, scope);
            }
        }
        return this.translations;
    }
    /**
     * Gets an object of translations for a given language
     *
     * @example
     *
     * selectTranslation().subscribe() - will return the current lang translation
     * selectTranslation('es').subscribe()
     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation
     * selectTranslation('admin-page/es').subscribe()
     */
    selectTranslation(lang) {
        let language$ = this.langChanges$;
        if (lang) {
            const scopeLangSpecified = getLangFromScope(lang) !== lang;
            if (this.isLang(lang) || scopeLangSpecified) {
                language$ = of(lang);
            }
            else {
                language$ = this.langChanges$.pipe(map((currentLang) => `${lang}/${currentLang}`));
            }
        }
        return language$.pipe(switchMap((language) => this.load(language).pipe(map(() => this.getTranslation(language)))));
    }
    /**
     * Sets or merge a given translation object to current lang
     *
     * @example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     */
    setTranslation(translation, lang = this.getActiveLang(), options = {}) {
        const defaults = { merge: true, emitChange: true };
        const mergedOptions = { ...defaults, ...options };
        const scope = getScopeFromLang(lang);
        /**
         * If this isn't a scope we use the whole translation as is
         * otherwise we need to flat the scope and use it
         */
        let flattenScopeOrTranslation = translation;
        // Merged the scoped language into the active language
        if (scope) {
            const key = this.getMappedScope(scope);
            flattenScopeOrTranslation = flatten({ [key]: translation });
        }
        const currentLang = scope ? getLangFromScope(lang) : lang;
        const mergedTranslation = {
            ...(mergedOptions.merge && this.getTranslation(currentLang)),
            ...flattenScopeOrTranslation,
        };
        const flattenTranslation = this.mergedConfig.flatten.aot
            ? mergedTranslation
            : flatten(mergedTranslation);
        const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);
        this.translations.set(currentLang, withHook);
        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());
    }
    /**
     * Sets translation key with given value
     *
     * @example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )
     */
    setTranslationKey(key, value, 
    // Todo: Add the lang to the options in v3
    lang = this.getActiveLang(), options = {}) {
        const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);
        const newValue = {
            [key]: withHook,
        };
        this.setTranslation(newValue, lang, { ...options, merge: true });
    }
    /**
     * Sets the fallback lang for the currently active language
     * @param fallbackLang
     */
    setFallbackLangForMissingTranslation({ fallbackLang, }) {
        const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;
        if (fallbackLang && this.useFallbackTranslation(lang)) {
            this.firstFallbackLang = lang;
        }
    }
    /**
     * @internal
     */
    _handleMissingKey(key, value, params) {
        if (this.config.missingHandler.allowEmpty && value === '') {
            return '';
        }
        if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {
            // We need to set it to true to prevent a loop
            this.isResolvedMissingOnce = true;
            const fallbackValue = this.translate(key, params, this.firstFallbackLang);
            this.isResolvedMissingOnce = false;
            return fallbackValue;
        }
        return this.missingHandler.handle(key, this.getMissingHandlerData(), params);
    }
    /**
     * @internal
     */
    _isLangScoped(lang) {
        return this.getAvailableLangsIds().indexOf(lang) === -1;
    }
    /**
     * Checks if a given string is one of the specified available languages.
     * @returns
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    isLang(lang) {
        return this.getAvailableLangsIds().indexOf(lang) !== -1;
    }
    /**
     * @internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     */
    _loadDependencies(path, inlineLoader) {
        const mainLang = getLangFromScope(path);
        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {
            return combineLatest(this.load(mainLang), this.load(path, { inlineLoader }));
        }
        return this.load(path, { inlineLoader });
    }
    /**
     * @internal
     */
    _completeScopeWithLang(langOrScope) {
        if (this._isLangScoped(langOrScope) &&
            !this.isLang(getLangFromScope(langOrScope))) {
            return `${langOrScope}/${this.getActiveLang()}`;
        }
        return langOrScope;
    }
    /**
     * @internal
     */
    _setScopeAlias(scope, alias) {
        if (!this.mergedConfig.scopeMapping) {
            this.mergedConfig.scopeMapping = {};
        }
        this.mergedConfig.scopeMapping[scope] = alias;
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
            // callback within its `destination` property, preventing classes from being GC'd.
            this.subscription = null;
        }
        // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.
        // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from
        // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created
        // and destroyed per each HTTP request, but any service is not getting GC'd.
        this.cache.clear();
    }
    isLoadedTranslation(lang) {
        return size(this.getTranslation(lang));
    }
    getAvailableLangsIds() {
        const first = this.getAvailableLangs()[0];
        if (isString(first)) {
            return this.getAvailableLangs();
        }
        return this.getAvailableLangs().map((l) => l.id);
    }
    getMissingHandlerData() {
        return {
            ...this.config,
            activeLang: this.getActiveLang(),
            availableLangs: this.availableLangs,
            defaultLang: this.defaultLang,
        };
    }
    /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     */
    useFallbackTranslation(lang) {
        return (this.config.missingHandler.useFallbackTranslation &&
            lang !== this.firstFallbackLang);
    }
    handleSuccess(lang, translation) {
        this.setTranslation(translation, lang, { emitChange: false });
        this.events.next({
            wasFailure: !!this.failedLangs.size,
            type: 'translationLoadSuccess',
            payload: getEventPayload(lang),
        });
        this.failedLangs.forEach((l) => this.cache.delete(l));
        this.failedLangs.clear();
    }
    handleFailure(lang, loadOptions) {
        // When starting to load a first choice language, initialize
        // the failed counter and resolve the fallback langs.
        if (isNil(loadOptions.failedCounter)) {
            loadOptions.failedCounter = 0;
            if (!loadOptions.fallbackLangs) {
                loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);
            }
        }
        const splitted = lang.split('/');
        const fallbacks = loadOptions.fallbackLangs;
        const nextLang = fallbacks[loadOptions.failedCounter];
        this.failedLangs.add(lang);
        // This handles the case where a loaded fallback language is requested again
        if (this.cache.has(nextLang)) {
            this.handleSuccess(nextLang, this.getTranslation(nextLang));
            return EMPTY;
        }
        const isFallbackLang = nextLang === splitted[splitted.length - 1];
        if (!nextLang || isFallbackLang) {
            let msg = `Unable to load translation and all the fallback languages`;
            if (splitted.length > 1) {
                msg += `, did you misspelled the scope name?`;
            }
            throw new Error(msg);
        }
        let resolveLang = nextLang;
        // if it's scoped lang
        if (splitted.length > 1) {
            // We need to resolve it to:
            // todos/langNotExists => todos/nextLang
            splitted[splitted.length - 1] = nextLang;
            resolveLang = splitted.join('/');
        }
        loadOptions.failedCounter++;
        this.events.next({
            type: 'translationLoadFailure',
            payload: getEventPayload(lang),
        });
        return this.load(resolveLang, loadOptions);
    }
    getMappedScope(scope) {
        const { scopeMapping = {} } = this.config;
        return scopeMapping[scope] || toCamelCase(scope);
    }
    /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     */
    resolveLangAndScope(lang) {
        let resolveLang = lang;
        let scope;
        if (this._isLangScoped(lang)) {
            // en for example
            const langFromScope = getLangFromScope(lang);
            // en is lang
            const hasLang = this.isLang(langFromScope);
            // take en
            resolveLang = hasLang ? langFromScope : this.getActiveLang();
            // find the scope
            scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);
        }
        return { scope, resolveLang };
    }
    getObjectByKey(translation, key) {
        const result = {};
        const prefix = `${key}.`;
        for (const currentKey in translation) {
            if (currentKey.startsWith(prefix)) {
                result[currentKey.replace(prefix, '')] = translation[currentKey];
            }
        }
        return result;
    }
    getEntries(key) {
        return key instanceof Map ? key.entries() : Object.entries(key);
    }
}
TranslocoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.10", ngImport: i0, type: TranslocoService, deps: [{ token: TRANSLOCO_LOADER, optional: true }, { token: TRANSLOCO_TRANSPILER }, { token: TRANSLOCO_MISSING_HANDLER }, { token: TRANSLOCO_INTERCEPTOR }, { token: TRANSLOCO_CONFIG }, { token: TRANSLOCO_FALLBACK_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });
TranslocoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.10", ngImport: i0, type: TranslocoService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.10", ngImport: i0, type: TranslocoService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSLOCO_LOADER]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TRANSLOCO_TRANSPILER]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TRANSLOCO_MISSING_HANDLER]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TRANSLOCO_INTERCEPTOR]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TRANSLOCO_CONFIG]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TRANSLOCO_FALLBACK_STRATEGY]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJzL3RyYW5zbG9jby9zcmMvbGliL3RyYW5zbG9jby5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFhLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RSxPQUFPLEVBQ0wsZUFBZSxFQUNmLGFBQWEsRUFDYixLQUFLLEVBQ0wsUUFBUSxFQUNSLElBQUksRUFFSixFQUFFLEVBQ0YsT0FBTyxHQUVSLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUNMLFVBQVUsRUFDVixHQUFHLEVBQ0gsS0FBSyxFQUNMLFdBQVcsRUFDWCxTQUFTLEVBQ1QsR0FBRyxHQUNKLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUNMLGFBQWEsRUFDYixnQkFBZ0IsR0FFakIsTUFBTSxvQkFBb0IsQ0FBQztBQUM1QixPQUFPLEVBQ0wsb0JBQW9CLEdBRXJCLE1BQU0sd0JBQXdCLENBQUM7QUFjaEMsT0FBTyxFQUNMLE9BQU8sRUFDUCxPQUFPLEVBQ1AsS0FBSyxFQUNMLGFBQWEsRUFDYixRQUFRLEVBQ1IsSUFBSSxFQUNKLFdBQVcsRUFDWCxTQUFTLEdBQ1YsTUFBTSxXQUFXLENBQUM7QUFDbkIsT0FBTyxFQUNMLGFBQWEsRUFDYixnQkFBZ0IsR0FFakIsTUFBTSxvQkFBb0IsQ0FBQztBQUM1QixPQUFPLEVBQ0wseUJBQXlCLEdBRzFCLE1BQU0sNkJBQTZCLENBQUM7QUFDckMsT0FBTyxFQUNMLHFCQUFxQixHQUV0QixNQUFNLHlCQUF5QixDQUFDO0FBQ2pDLE9BQU8sRUFDTCwyQkFBMkIsR0FFNUIsTUFBTSwrQkFBK0IsQ0FBQztBQUN2QyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUNMLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsZ0JB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Z0JBQWdCLDZCQUM1QixvQkFBb0IsYUFDcEIseUJBQXlCLGFBRXpCLHFCQUFxQixhQUNyQixnQkFBZ0IsYUFDaEIsMkJBQTJCO2tIQTFCMUIsZ0JBQWdCLGNBREgsTUFBTTs0RkFDbkIsZ0JBQWdCO2tCQUQ1QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7MEJBcUI3QixRQUFROzswQkFBSSxNQUFNOzJCQUFDLGdCQUFnQjs7MEJBQ25DLE1BQU07MkJBQUMsb0JBQW9COzswQkFDM0IsTUFBTTsyQkFBQyx5QkFBeUI7OzBCQUVoQyxNQUFNOzJCQUFDLHFCQUFxQjs7MEJBQzVCLE1BQU07MkJBQUMsZ0JBQWdCOzswQkFDdkIsTUFBTTsyQkFBQywyQkFBMkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEJlaGF2aW9yU3ViamVjdCxcbiAgY29tYmluZUxhdGVzdCxcbiAgRU1QVFksXG4gIGZvcmtKb2luLFxuICBmcm9tLFxuICBPYnNlcnZhYmxlLFxuICBvZixcbiAgU3ViamVjdCxcbiAgU3Vic2NyaXB0aW9uLFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIG1hcCxcbiAgcmV0cnksXG4gIHNoYXJlUmVwbGF5LFxuICBzd2l0Y2hNYXAsXG4gIHRhcCxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgRGVmYXVsdExvYWRlcixcbiAgVFJBTlNMT0NPX0xPQURFUixcbiAgVHJhbnNsb2NvTG9hZGVyLFxufSBmcm9tICcuL3RyYW5zbG9jby5sb2FkZXInO1xuaW1wb3J0IHtcbiAgVFJBTlNMT0NPX1RSQU5TUElMRVIsXG4gIFRyYW5zbG9jb1RyYW5zcGlsZXIsXG59IGZyb20gJy4vdHJhbnNsb2NvLnRyYW5zcGlsZXInO1xuaW1wb3J0IHtcbiAgQXZhaWxhYmxlTGFuZ3MsXG4gIEhhc2hNYXAsXG4gIElubGluZUxvYWRlcixcbiAgTG9hZE9wdGlvbnMsXG4gIFByb3ZpZGVyU2NvcGUsXG4gIFNldFRyYW5zbGF0aW9uT3B0aW9ucyxcbiAgVHJhbnNsYXRlT2JqZWN0UGFyYW1zLFxuICBUcmFuc2xhdGVQYXJhbXMsXG4gIFRyYW5zbGF0aW9uLFxuICBUcmFuc2xvY29FdmVudHMsXG4gIFRyYW5zbG9jb1Njb3BlLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7XG4gIGZsYXR0ZW4sXG4gIGlzRW1wdHksXG4gIGlzTmlsLFxuICBpc1Njb3BlT2JqZWN0LFxuICBpc1N0cmluZyxcbiAgc2l6ZSxcbiAgdG9DYW1lbENhc2UsXG4gIHVuZmxhdHRlbixcbn0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7XG4gIGRlZmF1bHRDb25maWcsXG4gIFRSQU5TTE9DT19DT05GSUcsXG4gIFRyYW5zbG9jb0NvbmZpZyxcbn0gZnJvbSAnLi90cmFuc2xvY28uY29uZmlnJztcbmltcG9ydCB7XG4gIFRSQU5TTE9DT19NSVNTSU5HX0hBTkRMRVIsXG4gIFRyYW5zbG9jb01pc3NpbmdIYW5kbGVyLFxuICBUcmFuc2xvY29NaXNzaW5nSGFuZGxlckRhdGEsXG59IGZyb20gJy4vdHJhbnNsb2NvLW1pc3NpbmctaGFuZGxlcic7XG5pbXBvcnQge1xuICBUUkFOU0xPQ09fSU5URVJDRVBUT1IsXG4gIFRyYW5zbG9jb0ludGVyY2VwdG9yLFxufSBmcm9tICcuL3RyYW5zbG9jby5pbnRlcmNlcHRvcic7XG5pbXBvcnQge1xuICBUUkFOU0xPQ09fRkFMTEJBQ0tfU1RSQVRFR1ksXG4gIFRyYW5zbG9jb0ZhbGxiYWNrU3RyYXRlZ3ksXG59IGZyb20gJy4vdHJhbnNsb2NvLWZhbGxiYWNrLXN0cmF0ZWd5JztcbmltcG9ydCB7IG1lcmdlQ29uZmlnIH0gZnJvbSAnLi9tZXJnZS1jb25maWcnO1xuaW1wb3J0IHtcbiAgZ2V0RXZlbnRQYXlsb2FkLFxuICBnZXRMYW5nRnJvbVNjb3BlLFxuICBnZXRTY29wZUZyb21MYW5nLFxuICByZXNvbHZlSW5saW5lTG9hZGVyLFxufSBmcm9tICcuL3NoYXJlZCc7XG5pbXBvcnQgeyBnZXRGYWxsYmFja3NMb2FkZXJzIH0gZnJvbSAnLi9nZXQtZmFsbGJhY2tzLWxvYWRlcnMnO1xuaW1wb3J0IHsgcmVzb2x2ZUxvYWRlciB9IGZyb20gJy4vcmVzb2x2ZS1sb2FkZXInO1xuXG5sZXQgc2VydmljZTogVHJhbnNsb2NvU2VydmljZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZTxUID0gc3RyaW5nPihcbiAga2V5OiBUcmFuc2xhdGVQYXJhbXMsXG4gIHBhcmFtczogSGFzaE1hcCA9IHt9LFxuICBsYW5nPzogc3RyaW5nXG4pOiBUIHtcbiAgcmV0dXJuIHNlcnZpY2UudHJhbnNsYXRlPFQ+KGtleSwgcGFyYW1zLCBsYW5nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZU9iamVjdDxUPihcbiAga2V5OiAgVHJhbnNsYXRlUGFyYW1zLFxuICBwYXJhbXM6IEhhc2hNYXAgPSB7fSxcbiAgbGFuZz86IHN0cmluZ1xuKTogVCB8IFRbXSB7XG4gIHJldHVybiBzZXJ2aWNlLnRyYW5zbGF0ZU9iamVjdDxUPihrZXksIHBhcmFtcywgbGFuZyk7XG59XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgVHJhbnNsb2NvU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGxhbmdDaGFuZ2VzJDogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0cmFuc2xhdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgVHJhbnNsYXRpb24+KCk7XG4gIHByaXZhdGUgY2FjaGUgPSBuZXcgTWFwPHN0cmluZywgT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbj4+KCk7XG4gIHByaXZhdGUgZmlyc3RGYWxsYmFja0xhbmc6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBkZWZhdWx0TGFuZyA9ICcnO1xuICBwcml2YXRlIGF2YWlsYWJsZUxhbmdzOiBBdmFpbGFibGVMYW5ncyA9IFtdO1xuICBwcml2YXRlIGlzUmVzb2x2ZWRNaXNzaW5nT25jZSA9IGZhbHNlO1xuICBwcml2YXRlIGxhbmc6IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+O1xuICBwcml2YXRlIGZhaWxlZExhbmdzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgbWVyZ2VkQ29uZmlnOiBUcmFuc2xvY29Db25maWcgJiB7XG4gICAgc2NvcGVNYXBwaW5nPzogSGFzaE1hcDxzdHJpbmc+O1xuICB9O1xuICBwcml2YXRlIGV2ZW50cyA9IG5ldyBTdWJqZWN0PFRyYW5zbG9jb0V2ZW50cz4oKTtcblxuICBldmVudHMkID0gdGhpcy5ldmVudHMuYXNPYnNlcnZhYmxlKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChUUkFOU0xPQ09fTE9BREVSKSBwcml2YXRlIGxvYWRlcjogVHJhbnNsb2NvTG9hZGVyLFxuICAgIEBJbmplY3QoVFJBTlNMT0NPX1RSQU5TUElMRVIpIHByaXZhdGUgcGFyc2VyOiBUcmFuc2xvY29UcmFuc3BpbGVyLFxuICAgIEBJbmplY3QoVFJBTlNMT0NPX01JU1NJTkdfSEFORExFUilcbiAgICBwcml2YXRlIG1pc3NpbmdIYW5kbGVyOiBUcmFuc2xvY29NaXNzaW5nSGFuZGxlcixcbiAgICBASW5qZWN0KFRSQU5TTE9DT19JTlRFUkNFUFRPUikgcHJpdmF0ZSBpbnRlcmNlcHRvcjogVHJhbnNsb2NvSW50ZXJjZXB0b3IsXG4gICAgQEluamVjdChUUkFOU0xPQ09fQ09ORklHKSBwcml2YXRlIHVzZXJDb25maWc6IFRyYW5zbG9jb0NvbmZpZyxcbiAgICBASW5qZWN0KFRSQU5TTE9DT19GQUxMQkFDS19TVFJBVEVHWSlcbiAgICBwcml2YXRlIGZhbGxiYWNrU3RyYXRlZ3k6IFRyYW5zbG9jb0ZhbGxiYWNrU3RyYXRlZ3lcbiAgKSB7XG4gICAgaWYgKCF0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgRGVmYXVsdExvYWRlcih0aGlzLnRyYW5zbGF0aW9ucyk7XG4gICAgfVxuICAgIHNlcnZpY2UgPSB0aGlzO1xuICAgIHRoaXMubWVyZ2VkQ29uZmlnID0gbWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgdGhpcy51c2VyQ29uZmlnKTtcblxuICAgIHRoaXMuc2V0QXZhaWxhYmxlTGFuZ3ModGhpcy5tZXJnZWRDb25maWcuYXZhaWxhYmxlTGFuZ3MgfHwgW10pO1xuICAgIHRoaXMuc2V0RmFsbGJhY2tMYW5nRm9yTWlzc2luZ1RyYW5zbGF0aW9uKHRoaXMubWVyZ2VkQ29uZmlnKTtcbiAgICB0aGlzLnNldERlZmF1bHRMYW5nKHRoaXMubWVyZ2VkQ29uZmlnLmRlZmF1bHRMYW5nKTtcbiAgICB0aGlzLmxhbmcgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4odGhpcy5nZXREZWZhdWx0TGFuZygpKTtcbiAgICAvLyBEb24ndCB1c2UgZGlzdGluY3RVbnRpbENoYW5nZWQgYXMgd2UgbmVlZCB0aGUgYWJpbGl0eSB0byB1cGRhdGVcbiAgICAvLyB0aGUgdmFsdWUgd2hlbiB1c2luZyBzZXRUcmFuc2xhdGlvbiBvciBzZXRUcmFuc2xhdGlvbktleXNcbiAgICB0aGlzLmxhbmdDaGFuZ2VzJCA9IHRoaXMubGFuZy5hc09ic2VydmFibGUoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgaGF2ZSBhIGZhaWx1cmUsIHdlIHdhbnQgdG8gZGVmaW5lIHRoZSBuZXh0IGxhbmd1YWdlIHRoYXQgc3VjY2VlZGVkIGFzIHRoZSBhY3RpdmVcbiAgICAgKi9cbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuZXZlbnRzJC5zdWJzY3JpYmUoKGUpID0+IHtcbiAgICAgIGlmIChlLnR5cGUgPT09ICd0cmFuc2xhdGlvbkxvYWRTdWNjZXNzJyAmJiBlLndhc0ZhaWx1cmUpIHtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVMYW5nKGUucGF5bG9hZC5sYW5nTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgY29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLm1lcmdlZENvbmZpZztcbiAgfVxuXG4gIGdldERlZmF1bHRMYW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRMYW5nO1xuICB9XG5cbiAgc2V0RGVmYXVsdExhbmcobGFuZzogc3RyaW5nKSB7XG4gICAgdGhpcy5kZWZhdWx0TGFuZyA9IGxhbmc7XG4gIH1cblxuICBnZXRBY3RpdmVMYW5nKCkge1xuICAgIHJldHVybiB0aGlzLmxhbmcuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIHNldEFjdGl2ZUxhbmcobGFuZzogc3RyaW5nKSB7XG4gICAgdGhpcy5sYW5nLm5leHQobGFuZyk7XG4gICAgdGhpcy5wYXJzZXIub25MYW5nQ2hhbmdlZD8uKGxhbmcpO1xuICAgIHRoaXMuZXZlbnRzLm5leHQoe1xuICAgICAgdHlwZTogJ2xhbmdDaGFuZ2VkJyxcbiAgICAgIHBheWxvYWQ6IGdldEV2ZW50UGF5bG9hZChsYW5nKSxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEF2YWlsYWJsZUxhbmdzKGxhbmdzOiBBdmFpbGFibGVMYW5ncykge1xuICAgIHRoaXMuYXZhaWxhYmxlTGFuZ3MgPSBsYW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBhdmFpbGFibGUgbGFuZ3VhZ2VzLlxuICAgKlxuICAgKiBAcmV0dXJuc1xuICAgKiBBbiBhcnJheSBvZiB0aGUgYXZhaWxhYmxlIGxhbmd1YWdlcy4gQ2FuIGJlIGVpdGhlciBhIGBzdHJpbmdbXWAgb3IgYSBgeyBpZDogc3RyaW5nOyBsYWJlbDogc3RyaW5nIH1bXWBcbiAgICogZGVwZW5kaW5nIG9uIGhvdyB0aGUgYXZhaWxhYmxlIGxhbmd1YWdlcyBhcmUgc2V0IGluIHlvdXIgbW9kdWxlLlxuICAgKi9cbiAgZ2V0QXZhaWxhYmxlTGFuZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlTGFuZ3M7XG4gIH1cblxuICBsb2FkKHBhdGg6IHN0cmluZywgb3B0aW9uczogTG9hZE9wdGlvbnMgPSB7fSk6IE9ic2VydmFibGU8VHJhbnNsYXRpb24+IHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmNhY2hlLmdldChwYXRoKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGxldCBsb2FkVHJhbnNsYXRpb246IE9ic2VydmFibGU8XG4gICAgICBUcmFuc2xhdGlvbiB8IHsgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uOyBsYW5nOiBzdHJpbmcgfVtdXG4gICAgPjtcbiAgICBjb25zdCBpc1Njb3BlID0gdGhpcy5faXNMYW5nU2NvcGVkKHBhdGgpO1xuICAgIGxldCBzY29wZTogc3RyaW5nO1xuICAgIGlmIChpc1Njb3BlKSB7XG4gICAgICBzY29wZSA9IGdldFNjb3BlRnJvbUxhbmcocGF0aCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9hZGVyc09wdGlvbnMgPSB7XG4gICAgICBwYXRoLFxuICAgICAgbWFpbkxvYWRlcjogdGhpcy5sb2FkZXIsXG4gICAgICBpbmxpbmVMb2FkZXI6IG9wdGlvbnMuaW5saW5lTG9hZGVyLFxuICAgICAgZGF0YTogaXNTY29wZSA/IHsgc2NvcGU6IHNjb3BlISB9IDogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy51c2VGYWxsYmFja1RyYW5zbGF0aW9uKHBhdGgpKSB7XG4gICAgICAvLyBpZiB0aGUgcGF0aCBpcyBzY29wZSB0aGUgZmFsbGJhY2sgc2hvdWxkIGJlIGBzY29wZS9mYWxsYmFja0xhbmdgO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSBpc1Njb3BlXG4gICAgICAgID8gYCR7c2NvcGUhfS8ke3RoaXMuZmlyc3RGYWxsYmFja0xhbmd9YFxuICAgICAgICA6IHRoaXMuZmlyc3RGYWxsYmFja0xhbmc7XG5cbiAgICAgIGNvbnN0IGxvYWRlcnMgPSBnZXRGYWxsYmFja3NMb2FkZXJzKHtcbiAgICAgICAgLi4ubG9hZGVyc09wdGlvbnMsXG4gICAgICAgIGZhbGxiYWNrUGF0aDogZmFsbGJhY2shLFxuICAgICAgfSk7XG4gICAgICBsb2FkVHJhbnNsYXRpb24gPSBmb3JrSm9pbihsb2FkZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbG9hZGVyID0gcmVzb2x2ZUxvYWRlcihsb2FkZXJzT3B0aW9ucyk7XG4gICAgICBsb2FkVHJhbnNsYXRpb24gPSBmcm9tKGxvYWRlcik7XG4gICAgfVxuXG4gICAgY29uc3QgbG9hZCQgPSBsb2FkVHJhbnNsYXRpb24ucGlwZShcbiAgICAgIHJldHJ5KHRoaXMuY29uZmlnLmZhaWxlZFJldHJpZXMpLFxuICAgICAgdGFwKCh0cmFuc2xhdGlvbikgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2xhdGlvbikpIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbi5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN1Y2Nlc3ModC5sYW5nLCB0LnRyYW5zbGF0aW9uKTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGZhbGxiYWNrIGluIGNhY2hlIHNvIHdlJ2xsIG5vdCBjcmVhdGUgYSByZWR1bmRhbnQgcmVxdWVzdFxuICAgICAgICAgICAgaWYgKHQubGFuZyAhPT0gcGF0aCkge1xuICAgICAgICAgICAgICB0aGlzLmNhY2hlLnNldCh0LmxhbmcsIG9mKHt9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlU3VjY2VzcyhwYXRoLCB0cmFuc2xhdGlvbik7XG4gICAgICB9KSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5tZXJnZWRDb25maWcucHJvZE1vZGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGlsZSB0cnlpbmcgdG8gbG9hZCBcIiR7cGF0aH1cImAsIGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUZhaWx1cmUocGF0aCwgb3B0aW9ucyk7XG4gICAgICB9KSxcbiAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgKTtcblxuICAgIHRoaXMuY2FjaGUuc2V0KHBhdGgsIGxvYWQkKTtcblxuICAgIHJldHVybiBsb2FkJDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbnN0YW50IHRyYW5zbGF0ZWQgdmFsdWUgb2YgYSBrZXlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdHJhbnNsYXRlPHN0cmluZz4oJ2hlbGxvJylcbiAgICogdHJhbnNsYXRlKCdoZWxsbycsIHsgdmFsdWU6ICd2YWx1ZScgfSlcbiAgICogdHJhbnNsYXRlPHN0cmluZ1tdPihbJ2hlbGxvJywgJ2tleSddKVxuICAgKiB0cmFuc2xhdGUoJ2hlbGxvJywgeyB9LCAnZW4nKVxuICAgKiB0cmFuc2xhdGUoJ3Njb3BlLnNvbWVLZXknLCB7IH0sICdlbicpXG4gICAqL1xuICB0cmFuc2xhdGU8VCA9IHN0cmluZz4oXG4gICAga2V5OiBUcmFuc2xhdGVQYXJhbXMsXG4gICAgcGFyYW1zOiBIYXNoTWFwID0ge30sXG4gICAgbGFuZyA9IHRoaXMuZ2V0QWN0aXZlTGFuZygpXG4gICk6IFQge1xuICAgIGlmICgha2V5KSByZXR1cm4ga2V5IGFzIGFueTtcblxuICAgIGNvbnN0IHsgc2NvcGUsIHJlc29sdmVMYW5nIH0gPSB0aGlzLnJlc29sdmVMYW5nQW5kU2NvcGUobGFuZyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICByZXR1cm4ga2V5Lm1hcCgoaykgPT5cbiAgICAgICAgdGhpcy50cmFuc2xhdGUoc2NvcGUgPyBgJHtzY29wZX0uJHtrfWAgOiBrLCBwYXJhbXMsIHJlc29sdmVMYW5nKVxuICAgICAgKSBhcyBhbnk7XG4gICAgfVxuXG4gICAga2V5ID0gc2NvcGUgPyBgJHtzY29wZX0uJHtrZXl9YCA6IGtleTtcblxuICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gdGhpcy5nZXRUcmFuc2xhdGlvbihyZXNvbHZlTGFuZyk7XG4gICAgY29uc3QgdmFsdWUgPSB0cmFuc2xhdGlvbltrZXldO1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU1pc3NpbmdLZXkoa2V5LCB2YWx1ZSwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZXIudHJhbnNwaWxlKHZhbHVlLCBwYXJhbXMsIHRyYW5zbGF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0cmFuc2xhdGVkIHZhbHVlIG9mIGEga2V5IGFzIG9ic2VydmFibGVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogc2VsZWN0VHJhbnNsYXRlPHN0cmluZz4oJ2hlbGxvJykuc3Vic2NyaWJlKHZhbHVlID0+IC4uLilcbiAgICogc2VsZWN0VHJhbnNsYXRlPHN0cmluZz4oJ2hlbGxvJywge30sICdlcycpLnN1YnNjcmliZSh2YWx1ZSA9PiAuLi4pXG4gICAqIHNlbGVjdFRyYW5zbGF0ZTxzdHJpbmc+KCdoZWxsbycsIHt9LCAndG9kb3MnKS5zdWJzY3JpYmUodmFsdWUgPT4gLi4uKVxuICAgKiBzZWxlY3RUcmFuc2xhdGU8c3RyaW5nPignaGVsbG8nLCB7fSwgeyBzY29wZTogJ3RvZG9zJyB9KS5zdWJzY3JpYmUodmFsdWUgPT4gLi4uKVxuICAgKlxuICAgKi9cbiAgc2VsZWN0VHJhbnNsYXRlPFQgPSBhbnk+KFxuICAgIGtleTogVHJhbnNsYXRlUGFyYW1zLFxuICAgIHBhcmFtcz86IEhhc2hNYXAsXG4gICAgbGFuZz86IHN0cmluZyB8IFRyYW5zbG9jb1Njb3BlLFxuICAgIF9pc09iamVjdCA9IGZhbHNlXG4gICk6IE9ic2VydmFibGU8VD4ge1xuICAgIGxldCBpbmxpbmVMb2FkZXI6IElubGluZUxvYWRlciB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBsb2FkID0gKGxhbmc6IHN0cmluZywgb3B0aW9ucz86IExvYWRPcHRpb25zKSA9PlxuICAgICAgdGhpcy5sb2FkKGxhbmcsIG9wdGlvbnMpLnBpcGUoXG4gICAgICAgIG1hcCgoKSA9PlxuICAgICAgICAgIF9pc09iamVjdFxuICAgICAgICAgICAgPyB0aGlzLnRyYW5zbGF0ZU9iamVjdChrZXksIHBhcmFtcywgbGFuZylcbiAgICAgICAgICAgIDogdGhpcy50cmFuc2xhdGUoa2V5LCBwYXJhbXMsIGxhbmcpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgaWYgKGlzTmlsKGxhbmcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYW5nQ2hhbmdlcyQucGlwZShzd2l0Y2hNYXAoKGxhbmcpID0+IGxvYWQobGFuZykpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTY29wZU9iamVjdChsYW5nKSkge1xuICAgICAgLy8gaXQncyBhIHNjb3BlIG9iamVjdC5cbiAgICAgIGNvbnN0IHByb3ZpZGVyU2NvcGUgPSBsYW5nIGFzIFByb3ZpZGVyU2NvcGU7XG4gICAgICBsYW5nID0gcHJvdmlkZXJTY29wZS5zY29wZTtcbiAgICAgIGlubGluZUxvYWRlciA9IHJlc29sdmVJbmxpbmVMb2FkZXIocHJvdmlkZXJTY29wZSwgcHJvdmlkZXJTY29wZS5zY29wZSk7XG4gICAgfVxuXG4gICAgbGFuZyA9IGxhbmcgYXMgc3RyaW5nO1xuICAgIGlmICh0aGlzLmlzTGFuZyhsYW5nKSB8fCB0aGlzLmlzU2NvcGVXaXRoTGFuZyhsYW5nKSkge1xuICAgICAgcmV0dXJuIGxvYWQobGFuZyk7XG4gICAgfVxuICAgIC8vIGl0J3MgYSBzY29wZVxuICAgIGNvbnN0IHNjb3BlID0gbGFuZztcbiAgICByZXR1cm4gdGhpcy5sYW5nQ2hhbmdlcyQucGlwZShcbiAgICAgIHN3aXRjaE1hcCgobGFuZykgPT4gbG9hZChgJHtzY29wZX0vJHtsYW5nfWAsIHsgaW5saW5lTG9hZGVyIH0pKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc2NvcGUgd2l0aCBsYW5nXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHRvZG9zL2VuID0+IHRydWVcbiAgICogdG9kb3MgPT4gZmFsc2VcbiAgICovXG4gIHByaXZhdGUgaXNTY29wZVdpdGhMYW5nKGxhbmc6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmlzTGFuZyhnZXRMYW5nRnJvbVNjb3BlKGxhbmcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgdGhlIGdpdmVuIHBhdGggdGhhdCByZXR1cm5zIGFuIG9iamVjdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBzZXJ2aWNlLnRyYW5zbGF0ZU9iamVjdCgncGF0aC50by5vYmplY3QnLCB7J3N1YnBhdGgnOiB7IHZhbHVlOiAnc29tZVZhbHVlJ319KSA9PiByZXR1cm5zIHRyYW5zbGF0ZWQgb2JqZWN0XG4gICAqXG4gICAqL1xuICB0cmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBzdHJpbmcsIHBhcmFtcz86IEhhc2hNYXAsIGxhbmc/OiBzdHJpbmcpOiBUO1xuICB0cmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBzdHJpbmdbXSwgcGFyYW1zPzogSGFzaE1hcCwgbGFuZz86IHN0cmluZyk6IFRbXTtcbiAgdHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KFxuICAgIGtleTogVHJhbnNsYXRlUGFyYW1zLFxuICAgIHBhcmFtcz86IEhhc2hNYXAsXG4gICAgbGFuZz86IHN0cmluZ1xuICApOiBUIHwgVFtdO1xuICB0cmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oXG4gICAga2V5OiBIYXNoTWFwIHwgTWFwPHN0cmluZywgSGFzaE1hcD4sXG4gICAgcGFyYW1zPzogbnVsbCxcbiAgICBsYW5nPzogc3RyaW5nXG4gICk6IFRbXTtcbiAgdHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KFxuICAgIGtleTogVHJhbnNsYXRlT2JqZWN0UGFyYW1zLFxuICAgIHBhcmFtczogSGFzaE1hcCB8IG51bGwgPSB7fSxcbiAgICBsYW5nID0gdGhpcy5nZXRBY3RpdmVMYW5nKClcbiAgKTogVCB8IFRbXSB7XG4gICAgaWYgKGlzU3RyaW5nKGtleSkgfHwgQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICBjb25zdCB7IHJlc29sdmVMYW5nLCBzY29wZSB9ID0gdGhpcy5yZXNvbHZlTGFuZ0FuZFNjb3BlKGxhbmcpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICByZXR1cm4ga2V5Lm1hcCgoaykgPT5cbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZU9iamVjdChcbiAgICAgICAgICAgIHNjb3BlID8gYCR7c2NvcGV9LiR7a31gIDogayxcbiAgICAgICAgICAgIHBhcmFtcyEsXG4gICAgICAgICAgICByZXNvbHZlTGFuZ1xuICAgICAgICAgIClcbiAgICAgICAgKSBhcyBhbnk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gdGhpcy5nZXRUcmFuc2xhdGlvbihyZXNvbHZlTGFuZyk7XG4gICAgICBrZXkgPSBzY29wZSA/IGAke3Njb3BlfS4ke2tleX1gIDoga2V5O1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IHVuZmxhdHRlbih0aGlzLmdldE9iamVjdEJ5S2V5KHRyYW5zbGF0aW9uLCBrZXkpKTtcbiAgICAgIC8qIElmIGFuIGVtcHR5IG9iamVjdCB3YXMgcmV0dXJuZWQgd2Ugd2FudCB0byB0cnkgYW5kIHRyYW5zbGF0ZSB0aGUga2V5IGFzIGEgc3RyaW5nIGFuZCBub3QgYW4gb2JqZWN0ICovXG4gICAgICByZXR1cm4gaXNFbXB0eSh2YWx1ZSlcbiAgICAgICAgPyB0aGlzLnRyYW5zbGF0ZShrZXksIHBhcmFtcyEsIGxhbmcpXG4gICAgICAgIDogdGhpcy5wYXJzZXIudHJhbnNwaWxlKHZhbHVlLCBwYXJhbXMhLCB0cmFuc2xhdGlvbik7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNsYXRpb25zOiBUW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCBfcGFyYW1zXSBvZiB0aGlzLmdldEVudHJpZXMoa2V5KSkge1xuICAgICAgdHJhbnNsYXRpb25zLnB1c2godGhpcy50cmFuc2xhdGVPYmplY3QoX2tleSwgX3BhcmFtcywgbGFuZykpO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2xhdGlvbnM7XG4gIH1cblxuICBzZWxlY3RUcmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcGFyYW1zPzogSGFzaE1hcCxcbiAgICBsYW5nPzogc3RyaW5nXG4gICk6IE9ic2VydmFibGU8VD47XG4gIHNlbGVjdFRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihcbiAgICBrZXk6IHN0cmluZ1tdLFxuICAgIHBhcmFtcz86IEhhc2hNYXAsXG4gICAgbGFuZz86IHN0cmluZ1xuICApOiBPYnNlcnZhYmxlPFRbXT47XG4gIHNlbGVjdFRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihcbiAgICBrZXk6IEhhc2hNYXAgfCBNYXA8c3RyaW5nLCBIYXNoTWFwPixcbiAgICBwYXJhbXM/OiBudWxsLFxuICAgIGxhbmc/OiBzdHJpbmdcbiAgKTogT2JzZXJ2YWJsZTxUW10+O1xuICBzZWxlY3RUcmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oXG4gICAga2V5OiBUcmFuc2xhdGVPYmplY3RQYXJhbXMsXG4gICAgcGFyYW1zPzogSGFzaE1hcCB8IG51bGwsXG4gICAgbGFuZz86IHN0cmluZ1xuICApOiBPYnNlcnZhYmxlPFQ+IHwgT2JzZXJ2YWJsZTxUW10+IHtcbiAgICBpZiAoaXNTdHJpbmcoa2V5KSB8fCBBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdFRyYW5zbGF0ZTxUPihrZXksIHBhcmFtcyEsIGxhbmcsIHRydWUpO1xuICAgIH1cblxuICAgIGNvbnN0IFtbZmlyc3RLZXksIGZpcnN0UGFyYW1zXSwgLi4ucmVzdF0gPSB0aGlzLmdldEVudHJpZXMoa2V5KTtcblxuICAgIC8qIEluIG9yZGVyIHRvIGF2b2lkIHN1YnNjcmliaW5nIG11bHRpcGxlIHRpbWVzIHRvIHRoZSBsb2FkIGxhbmd1YWdlIGV2ZW50IGJ5IGNhbGxpbmcgc2VsZWN0VHJhbnNsYXRlT2JqZWN0IGZvciBlYWNoIHBhaXIsXG4gICAgICogd2UgbGlzdGVuIHRvIHdoZW4gdGhlIGZpcnN0IGtleSBoYXMgYmVlbiB0cmFuc2xhdGVkICh0aGUgbGFuZ3VhZ2UgaXMgbG9hZGVkKSBhbmQgdHJhbnNsYXRlIHRoZSByZXN0IHN5bmNocm9ub3VzbHkgKi9cbiAgICByZXR1cm4gdGhpcy5zZWxlY3RUcmFuc2xhdGVPYmplY3Q8VD4oZmlyc3RLZXksIGZpcnN0UGFyYW1zLCBsYW5nKS5waXBlKFxuICAgICAgbWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbnMgPSBbdmFsdWVdO1xuICAgICAgICBmb3IgKGNvbnN0IFtfa2V5LCBfcGFyYW1zXSBvZiByZXN0KSB7XG4gICAgICAgICAgdHJhbnNsYXRpb25zLnB1c2godGhpcy50cmFuc2xhdGVPYmplY3Q8VD4oX2tleSwgX3BhcmFtcywgbGFuZykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9ucztcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBvZiB0cmFuc2xhdGlvbnMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogZ2V0VHJhbnNsYXRpb24oKVxuICAgKiBnZXRUcmFuc2xhdGlvbignZW4nKVxuICAgKiBnZXRUcmFuc2xhdGlvbignYWRtaW4tcGFnZS9lbicpXG4gICAqL1xuICBnZXRUcmFuc2xhdGlvbigpOiBNYXA8c3RyaW5nLCBUcmFuc2xhdGlvbj47XG4gIGdldFRyYW5zbGF0aW9uKGxhbmdPclNjb3BlOiBzdHJpbmcpOiBUcmFuc2xhdGlvbjtcbiAgZ2V0VHJhbnNsYXRpb24obGFuZ09yU2NvcGU/OiBzdHJpbmcpOiBNYXA8c3RyaW5nLCBUcmFuc2xhdGlvbj4gfCBUcmFuc2xhdGlvbiB7XG4gICAgaWYgKGxhbmdPclNjb3BlKSB7XG4gICAgICBpZiAodGhpcy5pc0xhbmcobGFuZ09yU2NvcGUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9ucy5nZXQobGFuZ09yU2NvcGUpIHx8IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNjb3BlLCBidWlsZCB0aGUgc2NvcGUgdmFsdWUgZnJvbSB0aGUgdHJhbnNsYXRpb24gb2JqZWN0XG4gICAgICAgIGNvbnN0IHsgc2NvcGUsIHJlc29sdmVMYW5nIH0gPSB0aGlzLnJlc29sdmVMYW5nQW5kU2NvcGUobGFuZ09yU2NvcGUpO1xuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IHRoaXMudHJhbnNsYXRpb25zLmdldChyZXNvbHZlTGFuZykgfHwge307XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlLZXkodHJhbnNsYXRpb24sIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3Qgb2YgdHJhbnNsYXRpb25zIGZvciBhIGdpdmVuIGxhbmd1YWdlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHNlbGVjdFRyYW5zbGF0aW9uKCkuc3Vic2NyaWJlKCkgLSB3aWxsIHJldHVybiB0aGUgY3VycmVudCBsYW5nIHRyYW5zbGF0aW9uXG4gICAqIHNlbGVjdFRyYW5zbGF0aW9uKCdlcycpLnN1YnNjcmliZSgpXG4gICAqIHNlbGVjdFRyYW5zbGF0aW9uKCdhZG1pbi1wYWdlJykuc3Vic2NyaWJlKCkgLSB3aWxsIHJldHVybiB0aGUgY3VycmVudCBsYW5nIHNjb3BlIHRyYW5zbGF0aW9uXG4gICAqIHNlbGVjdFRyYW5zbGF0aW9uKCdhZG1pbi1wYWdlL2VzJykuc3Vic2NyaWJlKClcbiAgICovXG4gIHNlbGVjdFRyYW5zbGF0aW9uKGxhbmc/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uPiB7XG4gICAgbGV0IGxhbmd1YWdlJCA9IHRoaXMubGFuZ0NoYW5nZXMkO1xuICAgIGlmIChsYW5nKSB7XG4gICAgICBjb25zdCBzY29wZUxhbmdTcGVjaWZpZWQgPSBnZXRMYW5nRnJvbVNjb3BlKGxhbmcpICE9PSBsYW5nO1xuICAgICAgaWYgKHRoaXMuaXNMYW5nKGxhbmcpIHx8IHNjb3BlTGFuZ1NwZWNpZmllZCkge1xuICAgICAgICBsYW5ndWFnZSQgPSBvZihsYW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhbmd1YWdlJCA9IHRoaXMubGFuZ0NoYW5nZXMkLnBpcGUoXG4gICAgICAgICAgbWFwKChjdXJyZW50TGFuZykgPT4gYCR7bGFuZ30vJHtjdXJyZW50TGFuZ31gKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYW5ndWFnZSQucGlwZShcbiAgICAgIHN3aXRjaE1hcCgobGFuZ3VhZ2UpID0+XG4gICAgICAgIHRoaXMubG9hZChsYW5ndWFnZSkucGlwZShtYXAoKCkgPT4gdGhpcy5nZXRUcmFuc2xhdGlvbihsYW5ndWFnZSkpKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvciBtZXJnZSBhIGdpdmVuIHRyYW5zbGF0aW9uIG9iamVjdCB0byBjdXJyZW50IGxhbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogc2V0VHJhbnNsYXRpb24oeyAuLi4gfSlcbiAgICogc2V0VHJhbnNsYXRpb24oeyAuLi4gfSwgJ2VuJylcbiAgICogc2V0VHJhbnNsYXRpb24oeyAuLi4gfSwgJ2VzJywgeyBtZXJnZTogZmFsc2UgfSApXG4gICAqIHNldFRyYW5zbGF0aW9uKHsgLi4uIH0sICd0b2Rvcy9lbicsIHsgbWVyZ2U6IGZhbHNlIH0gKVxuICAgKi9cbiAgc2V0VHJhbnNsYXRpb24oXG4gICAgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uLFxuICAgIGxhbmcgPSB0aGlzLmdldEFjdGl2ZUxhbmcoKSxcbiAgICBvcHRpb25zOiBTZXRUcmFuc2xhdGlvbk9wdGlvbnMgPSB7fVxuICApIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHsgbWVyZ2U6IHRydWUsIGVtaXRDaGFuZ2U6IHRydWUgfTtcbiAgICBjb25zdCBtZXJnZWRPcHRpb25zID0geyAuLi5kZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGVGcm9tTGFuZyhsYW5nKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXNuJ3QgYSBzY29wZSB3ZSB1c2UgdGhlIHdob2xlIHRyYW5zbGF0aW9uIGFzIGlzXG4gICAgICogb3RoZXJ3aXNlIHdlIG5lZWQgdG8gZmxhdCB0aGUgc2NvcGUgYW5kIHVzZSBpdFxuICAgICAqL1xuICAgIGxldCBmbGF0dGVuU2NvcGVPclRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb247XG5cbiAgICAvLyBNZXJnZWQgdGhlIHNjb3BlZCBsYW5ndWFnZSBpbnRvIHRoZSBhY3RpdmUgbGFuZ3VhZ2VcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0TWFwcGVkU2NvcGUoc2NvcGUpO1xuICAgICAgZmxhdHRlblNjb3BlT3JUcmFuc2xhdGlvbiA9IGZsYXR0ZW4oeyBba2V5XTogdHJhbnNsYXRpb24gfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudExhbmcgPSBzY29wZSA/IGdldExhbmdGcm9tU2NvcGUobGFuZykgOiBsYW5nO1xuXG4gICAgY29uc3QgbWVyZ2VkVHJhbnNsYXRpb24gPSB7XG4gICAgICAuLi4obWVyZ2VkT3B0aW9ucy5tZXJnZSAmJiB0aGlzLmdldFRyYW5zbGF0aW9uKGN1cnJlbnRMYW5nKSksXG4gICAgICAuLi5mbGF0dGVuU2NvcGVPclRyYW5zbGF0aW9uLFxuICAgIH07XG5cbiAgICBjb25zdCBmbGF0dGVuVHJhbnNsYXRpb24gPSB0aGlzLm1lcmdlZENvbmZpZy5mbGF0dGVuIS5hb3RcbiAgICAgID8gbWVyZ2VkVHJhbnNsYXRpb25cbiAgICAgIDogZmxhdHRlbihtZXJnZWRUcmFuc2xhdGlvbik7XG4gICAgY29uc3Qgd2l0aEhvb2sgPSB0aGlzLmludGVyY2VwdG9yLnByZVNhdmVUcmFuc2xhdGlvbihcbiAgICAgIGZsYXR0ZW5UcmFuc2xhdGlvbixcbiAgICAgIGN1cnJlbnRMYW5nXG4gICAgKTtcbiAgICB0aGlzLnRyYW5zbGF0aW9ucy5zZXQoY3VycmVudExhbmcsIHdpdGhIb29rKTtcbiAgICBtZXJnZWRPcHRpb25zLmVtaXRDaGFuZ2UgJiYgdGhpcy5zZXRBY3RpdmVMYW5nKHRoaXMuZ2V0QWN0aXZlTGFuZygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRyYW5zbGF0aW9uIGtleSB3aXRoIGdpdmVuIHZhbHVlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHNldFRyYW5zbGF0aW9uS2V5KCdrZXknLCAndmFsdWUnKVxuICAgKiBzZXRUcmFuc2xhdGlvbktleSgna2V5Lm5lc3RlZCcsICd2YWx1ZScpXG4gICAqIHNldFRyYW5zbGF0aW9uS2V5KCdrZXkubmVzdGVkJywgJ3ZhbHVlJywgJ2VuJylcbiAgICogc2V0VHJhbnNsYXRpb25LZXkoJ2tleS5uZXN0ZWQnLCAndmFsdWUnLCAnZW4nLCB7IGVtaXRDaGFuZ2U6IGZhbHNlIH0gKVxuICAgKi9cbiAgc2V0VHJhbnNsYXRpb25LZXkoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgICAvLyBUb2RvOiBBZGQgdGhlIGxhbmcgdG8gdGhlIG9wdGlvbnMgaW4gdjNcbiAgICBsYW5nID0gdGhpcy5nZXRBY3RpdmVMYW5nKCksXG4gICAgb3B0aW9uczogT21pdDxTZXRUcmFuc2xhdGlvbk9wdGlvbnMsICdtZXJnZSc+ID0ge31cbiAgKSB7XG4gICAgY29uc3Qgd2l0aEhvb2sgPSB0aGlzLmludGVyY2VwdG9yLnByZVNhdmVUcmFuc2xhdGlvbktleShrZXksIHZhbHVlLCBsYW5nKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHtcbiAgICAgIFtrZXldOiB3aXRoSG9vayxcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRUcmFuc2xhdGlvbihuZXdWYWx1ZSwgbGFuZywgeyAuLi5vcHRpb25zLCBtZXJnZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmYWxsYmFjayBsYW5nIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBsYW5ndWFnZVxuICAgKiBAcGFyYW0gZmFsbGJhY2tMYW5nXG4gICAqL1xuICBzZXRGYWxsYmFja0xhbmdGb3JNaXNzaW5nVHJhbnNsYXRpb24oe1xuICAgIGZhbGxiYWNrTGFuZyxcbiAgfTogUGljazxUcmFuc2xvY29Db25maWcsICdmYWxsYmFja0xhbmcnPikge1xuICAgIGNvbnN0IGxhbmcgPSBBcnJheS5pc0FycmF5KGZhbGxiYWNrTGFuZykgPyBmYWxsYmFja0xhbmdbMF0gOiBmYWxsYmFja0xhbmc7XG4gICAgaWYgKGZhbGxiYWNrTGFuZyAmJiB0aGlzLnVzZUZhbGxiYWNrVHJhbnNsYXRpb24obGFuZykpIHtcbiAgICAgIHRoaXMuZmlyc3RGYWxsYmFja0xhbmcgPSBsYW5nITtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaGFuZGxlTWlzc2luZ0tleShrZXk6IHN0cmluZywgdmFsdWU6IGFueSwgcGFyYW1zPzogSGFzaE1hcCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5taXNzaW5nSGFuZGxlciEuYWxsb3dFbXB0eSAmJiB2YWx1ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNSZXNvbHZlZE1pc3NpbmdPbmNlICYmIHRoaXMudXNlRmFsbGJhY2tUcmFuc2xhdGlvbigpKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHNldCBpdCB0byB0cnVlIHRvIHByZXZlbnQgYSBsb29wXG4gICAgICB0aGlzLmlzUmVzb2x2ZWRNaXNzaW5nT25jZSA9IHRydWU7XG4gICAgICBjb25zdCBmYWxsYmFja1ZhbHVlID0gdGhpcy50cmFuc2xhdGUoXG4gICAgICAgIGtleSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB0aGlzLmZpcnN0RmFsbGJhY2tMYW5nIVxuICAgICAgKTtcbiAgICAgIHRoaXMuaXNSZXNvbHZlZE1pc3NpbmdPbmNlID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiBmYWxsYmFja1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1pc3NpbmdIYW5kbGVyLmhhbmRsZShcbiAgICAgIGtleSxcbiAgICAgIHRoaXMuZ2V0TWlzc2luZ0hhbmRsZXJEYXRhKCksXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2lzTGFuZ1Njb3BlZChsYW5nOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdmFpbGFibGVMYW5nc0lkcygpLmluZGV4T2YobGFuZykgPT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIHN0cmluZyBpcyBvbmUgb2YgdGhlIHNwZWNpZmllZCBhdmFpbGFibGUgbGFuZ3VhZ2VzLlxuICAgKiBAcmV0dXJuc1xuICAgKiBUcnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYW4gYXZhaWxhYmxlIGxhbmd1YWdlLlxuICAgKiBGYWxzZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIG5vdCBhbiBhdmFpbGFibGUgbGFuZ3VhZ2UuXG4gICAqL1xuICBpc0xhbmcobGFuZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXZhaWxhYmxlTGFuZ3NJZHMoKS5pbmRleE9mKGxhbmcpICE9PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogV2UgYWx3YXlzIHdhbnQgdG8gbWFrZSBzdXJlIHRoZSBnbG9iYWwgbGFuZyBpcyBsb2FkZWRcbiAgICogYmVmb3JlIGxvYWRpbmcgdGhlIHNjb3BlIHNpbmNlIHlvdSBjYW4gYWNjZXNzIGJvdGggdmlhIHRoZSBwaXBlL2RpcmVjdGl2ZS5cbiAgICovXG4gIF9sb2FkRGVwZW5kZW5jaWVzKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBpbmxpbmVMb2FkZXI/OiBJbmxpbmVMb2FkZXJcbiAgKTogT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbiB8IFRyYW5zbGF0aW9uW10+IHtcbiAgICBjb25zdCBtYWluTGFuZyA9IGdldExhbmdGcm9tU2NvcGUocGF0aCk7XG5cbiAgICBpZiAodGhpcy5faXNMYW5nU2NvcGVkKHBhdGgpICYmICF0aGlzLmlzTG9hZGVkVHJhbnNsYXRpb24obWFpbkxhbmcpKSB7XG4gICAgICByZXR1cm4gY29tYmluZUxhdGVzdChcbiAgICAgICAgdGhpcy5sb2FkKG1haW5MYW5nKSxcbiAgICAgICAgdGhpcy5sb2FkKHBhdGgsIHsgaW5saW5lTG9hZGVyIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2FkKHBhdGgsIHsgaW5saW5lTG9hZGVyIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2NvbXBsZXRlU2NvcGVXaXRoTGFuZyhsYW5nT3JTY29wZTogc3RyaW5nKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5faXNMYW5nU2NvcGVkKGxhbmdPclNjb3BlKSAmJlxuICAgICAgIXRoaXMuaXNMYW5nKGdldExhbmdGcm9tU2NvcGUobGFuZ09yU2NvcGUpKVxuICAgICkge1xuICAgICAgcmV0dXJuIGAke2xhbmdPclNjb3BlfS8ke3RoaXMuZ2V0QWN0aXZlTGFuZygpfWA7XG4gICAgfVxuICAgIHJldHVybiBsYW5nT3JTY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRTY29wZUFsaWFzKHNjb3BlOiBzdHJpbmcsIGFsaWFzOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMubWVyZ2VkQ29uZmlnLnNjb3BlTWFwcGluZykge1xuICAgICAgdGhpcy5tZXJnZWRDb25maWcuc2NvcGVNYXBwaW5nID0ge307XG4gICAgfVxuICAgIHRoaXMubWVyZ2VkQ29uZmlnLnNjb3BlTWFwcGluZ1tzY29wZV0gPSBhbGlhcztcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIC8vIENhcmV0YWtlciBub3RlOiBpdCdzIGltcG9ydGFudCB0byBjbGVhbiB1cCByZWZlcmVuY2VzIHRvIHN1YnNjcmlwdGlvbnMgc2luY2UgdGhleSBzYXZlIHRoZSBgbmV4dGBcbiAgICAgIC8vIGNhbGxiYWNrIHdpdGhpbiBpdHMgYGRlc3RpbmF0aW9uYCBwcm9wZXJ0eSwgcHJldmVudGluZyBjbGFzc2VzIGZyb20gYmVpbmcgR0MnZC5cbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgLy8gQ2FyZXRha2VyIG5vdGU6IHNpbmNlIHRoaXMgaXMgdGhlIHJvb3QgcHJvdmlkZXIsIGl0J2xsIGJlIGRlc3Ryb3llZCB3aGVuIHRoZSBgTmdNb2R1bGVSZWYuZGVzdHJveSgpYCBpcyBydW4uXG4gICAgLy8gQ2FjaGVkIHZhbHVlcyBjYXB0dXJlIGB0aGlzYCwgdGh1cyBsZWFkaW5nIHRvIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGFuZCBwcmV2ZW50aW5nIHRoZSBgVHJhbnNsb2NvU2VydmljZWAgZnJvbVxuICAgIC8vIGJlaW5nIEdDJ2QuIFRoaXMgd291bGQgbGVhZCB0byBhIG1lbW9yeSBsZWFrIHdoZW4gc2VydmVyLXNpZGUgcmVuZGVyaW5nIGlzIHVzZWQgc2luY2UgdGhlIHNlcnZpY2UgaXMgY3JlYXRlZFxuICAgIC8vIGFuZCBkZXN0cm95ZWQgcGVyIGVhY2ggSFRUUCByZXF1ZXN0LCBidXQgYW55IHNlcnZpY2UgaXMgbm90IGdldHRpbmcgR0MnZC5cbiAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gIH1cblxuICBwcml2YXRlIGlzTG9hZGVkVHJhbnNsYXRpb24obGFuZzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHNpemUodGhpcy5nZXRUcmFuc2xhdGlvbihsYW5nKSk7XG4gIH1cblxuICBwcml2YXRlIGdldEF2YWlsYWJsZUxhbmdzSWRzKCk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZ2V0QXZhaWxhYmxlTGFuZ3MoKVswXTtcblxuICAgIGlmIChpc1N0cmluZyhmaXJzdCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF2YWlsYWJsZUxhbmdzKCkgYXMgc3RyaW5nW107XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLmdldEF2YWlsYWJsZUxhbmdzKCkgYXMgeyBpZDogc3RyaW5nIH1bXSkubWFwKChsKSA9PiBsLmlkKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TWlzc2luZ0hhbmRsZXJEYXRhKCk6IFRyYW5zbG9jb01pc3NpbmdIYW5kbGVyRGF0YSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgYWN0aXZlTGFuZzogdGhpcy5nZXRBY3RpdmVMYW5nKCksXG4gICAgICBhdmFpbGFibGVMYW5nczogdGhpcy5hdmFpbGFibGVMYW5ncyxcbiAgICAgIGRlZmF1bHRMYW5nOiB0aGlzLmRlZmF1bHRMYW5nLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVXNlIGEgZmFsbGJhY2sgdHJhbnNsYXRpb24gc2V0IGZvciBtaXNzaW5nIGtleXMgb2YgdGhlIHByaW1hcnkgbGFuZ3VhZ2VcbiAgICogVGhpcyBpcyB1bnJlbGF0ZWQgdG8gdGhlIGZhbGxiYWNrIGxhbmd1YWdlICh3aGljaCBjaGFuZ2VzIHRoZSBhY3RpdmUgbGFuZ3VhZ2UpXG4gICAqL1xuICBwcml2YXRlIHVzZUZhbGxiYWNrVHJhbnNsYXRpb24obGFuZz86IHN0cmluZykge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmNvbmZpZy5taXNzaW5nSGFuZGxlciEudXNlRmFsbGJhY2tUcmFuc2xhdGlvbiAmJlxuICAgICAgbGFuZyAhPT0gdGhpcy5maXJzdEZhbGxiYWNrTGFuZ1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVN1Y2Nlc3MobGFuZzogc3RyaW5nLCB0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24pIHtcbiAgICB0aGlzLnNldFRyYW5zbGF0aW9uKHRyYW5zbGF0aW9uLCBsYW5nLCB7IGVtaXRDaGFuZ2U6IGZhbHNlIH0pO1xuICAgIHRoaXMuZXZlbnRzLm5leHQoe1xuICAgICAgd2FzRmFpbHVyZTogISF0aGlzLmZhaWxlZExhbmdzLnNpemUsXG4gICAgICB0eXBlOiAndHJhbnNsYXRpb25Mb2FkU3VjY2VzcycsXG4gICAgICBwYXlsb2FkOiBnZXRFdmVudFBheWxvYWQobGFuZyksXG4gICAgfSk7XG4gICAgdGhpcy5mYWlsZWRMYW5ncy5mb3JFYWNoKChsKSA9PiB0aGlzLmNhY2hlLmRlbGV0ZShsKSk7XG4gICAgdGhpcy5mYWlsZWRMYW5ncy5jbGVhcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVGYWlsdXJlKGxhbmc6IHN0cmluZywgbG9hZE9wdGlvbnM6IExvYWRPcHRpb25zKSB7XG4gICAgLy8gV2hlbiBzdGFydGluZyB0byBsb2FkIGEgZmlyc3QgY2hvaWNlIGxhbmd1YWdlLCBpbml0aWFsaXplXG4gICAgLy8gdGhlIGZhaWxlZCBjb3VudGVyIGFuZCByZXNvbHZlIHRoZSBmYWxsYmFjayBsYW5ncy5cbiAgICBpZiAoaXNOaWwobG9hZE9wdGlvbnMuZmFpbGVkQ291bnRlcikpIHtcbiAgICAgIGxvYWRPcHRpb25zLmZhaWxlZENvdW50ZXIgPSAwO1xuXG4gICAgICBpZiAoIWxvYWRPcHRpb25zLmZhbGxiYWNrTGFuZ3MpIHtcbiAgICAgICAgbG9hZE9wdGlvbnMuZmFsbGJhY2tMYW5ncyA9IHRoaXMuZmFsbGJhY2tTdHJhdGVneS5nZXROZXh0TGFuZ3MobGFuZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3BsaXR0ZWQgPSBsYW5nLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgZmFsbGJhY2tzID0gbG9hZE9wdGlvbnMuZmFsbGJhY2tMYW5ncztcbiAgICBjb25zdCBuZXh0TGFuZyA9IGZhbGxiYWNrcyFbbG9hZE9wdGlvbnMuZmFpbGVkQ291bnRlciFdO1xuICAgIHRoaXMuZmFpbGVkTGFuZ3MuYWRkKGxhbmcpO1xuXG4gICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIGEgbG9hZGVkIGZhbGxiYWNrIGxhbmd1YWdlIGlzIHJlcXVlc3RlZCBhZ2FpblxuICAgIGlmICh0aGlzLmNhY2hlLmhhcyhuZXh0TGFuZykpIHtcbiAgICAgIHRoaXMuaGFuZGxlU3VjY2VzcyhuZXh0TGFuZywgdGhpcy5nZXRUcmFuc2xhdGlvbihuZXh0TGFuZykpO1xuICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRmFsbGJhY2tMYW5nID0gbmV4dExhbmcgPT09IHNwbGl0dGVkW3NwbGl0dGVkLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCFuZXh0TGFuZyB8fCBpc0ZhbGxiYWNrTGFuZykge1xuICAgICAgbGV0IG1zZyA9IGBVbmFibGUgdG8gbG9hZCB0cmFuc2xhdGlvbiBhbmQgYWxsIHRoZSBmYWxsYmFjayBsYW5ndWFnZXNgO1xuICAgICAgaWYgKHNwbGl0dGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbXNnICs9IGAsIGRpZCB5b3UgbWlzc3BlbGxlZCB0aGUgc2NvcGUgbmFtZT9gO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZUxhbmcgPSBuZXh0TGFuZztcbiAgICAvLyBpZiBpdCdzIHNjb3BlZCBsYW5nXG4gICAgaWYgKHNwbGl0dGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gcmVzb2x2ZSBpdCB0bzpcbiAgICAgIC8vIHRvZG9zL2xhbmdOb3RFeGlzdHMgPT4gdG9kb3MvbmV4dExhbmdcbiAgICAgIHNwbGl0dGVkW3NwbGl0dGVkLmxlbmd0aCAtIDFdID0gbmV4dExhbmc7XG4gICAgICByZXNvbHZlTGFuZyA9IHNwbGl0dGVkLmpvaW4oJy8nKTtcbiAgICB9XG5cbiAgICBsb2FkT3B0aW9ucy5mYWlsZWRDb3VudGVyISsrO1xuICAgIHRoaXMuZXZlbnRzLm5leHQoe1xuICAgICAgdHlwZTogJ3RyYW5zbGF0aW9uTG9hZEZhaWx1cmUnLFxuICAgICAgcGF5bG9hZDogZ2V0RXZlbnRQYXlsb2FkKGxhbmcpLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMubG9hZChyZXNvbHZlTGFuZywgbG9hZE9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRNYXBwZWRTY29wZShzY29wZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCB7IHNjb3BlTWFwcGluZyA9IHt9IH0gPSB0aGlzLmNvbmZpZztcbiAgICByZXR1cm4gc2NvcGVNYXBwaW5nW3Njb3BlXSB8fCB0b0NhbWVsQ2FzZShzY29wZSk7XG4gIH1cblxuICAvKipcbiAgICogSWYgbGFuZyBpcyBzY29wZSB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAqIHRvZG9zL2VzID0+IGluIHRoaXMgY2FzZSB3ZSBzaG91bGQgdGFrZSBgZXNgIGFzIGxhbmdcbiAgICogdG9kb3MgPT4gaW4gdGhpcyBjYXNlIHdlIHNob3VsZCBzZXQgdGhlIGFjdGl2ZSBsYW5nIGFzIGxhbmdcbiAgICovXG4gIHByaXZhdGUgcmVzb2x2ZUxhbmdBbmRTY29wZShsYW5nOiBzdHJpbmcpIHtcbiAgICBsZXQgcmVzb2x2ZUxhbmcgPSBsYW5nO1xuICAgIGxldCBzY29wZTtcblxuICAgIGlmICh0aGlzLl9pc0xhbmdTY29wZWQobGFuZykpIHtcbiAgICAgIC8vIGVuIGZvciBleGFtcGxlXG4gICAgICBjb25zdCBsYW5nRnJvbVNjb3BlID0gZ2V0TGFuZ0Zyb21TY29wZShsYW5nKTtcbiAgICAgIC8vIGVuIGlzIGxhbmdcbiAgICAgIGNvbnN0IGhhc0xhbmcgPSB0aGlzLmlzTGFuZyhsYW5nRnJvbVNjb3BlKTtcbiAgICAgIC8vIHRha2UgZW5cbiAgICAgIHJlc29sdmVMYW5nID0gaGFzTGFuZyA/IGxhbmdGcm9tU2NvcGUgOiB0aGlzLmdldEFjdGl2ZUxhbmcoKTtcbiAgICAgIC8vIGZpbmQgdGhlIHNjb3BlXG4gICAgICBzY29wZSA9IHRoaXMuZ2V0TWFwcGVkU2NvcGUoaGFzTGFuZyA/IGdldFNjb3BlRnJvbUxhbmcobGFuZykgOiBsYW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzY29wZSwgcmVzb2x2ZUxhbmcgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0T2JqZWN0QnlLZXkodHJhbnNsYXRpb246IFRyYW5zbGF0aW9uLCBrZXk/OiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXN1bHQ6IFRyYW5zbGF0aW9uID0ge307XG4gICAgY29uc3QgcHJlZml4ID0gYCR7a2V5fS5gO1xuXG4gICAgZm9yIChjb25zdCBjdXJyZW50S2V5IGluIHRyYW5zbGF0aW9uKSB7XG4gICAgICBpZiAoY3VycmVudEtleS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgcmVzdWx0W2N1cnJlbnRLZXkucmVwbGFjZShwcmVmaXgsICcnKV0gPSB0cmFuc2xhdGlvbltjdXJyZW50S2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRFbnRyaWVzKGtleTogSGFzaE1hcCB8IE1hcDxzdHJpbmcsIEhhc2hNYXA+KSB7XG4gICAgcmV0dXJuIGtleSBpbnN0YW5jZW9mIE1hcCA/IGtleS5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhrZXkpO1xuICB9XG59XG4iXX0=